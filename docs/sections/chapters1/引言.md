# 数据结构与算法

## 一、数据结构

数据结构是计算机科学的一个重要概念，它指的是在计算机中组织和存储数据的特殊方式，使得我们可以以不同的方式有效地访问和修改这些数据。数据结构通常包括数组、链表、树、哈希表、堆、队列、栈等。

数据结构的重要性主要表现在以下几个方面：

1. 高效性：有效的数据结构可以使我们以更快的速度检索和更新数据。例如，如果我们将数据存储在一个经过排序的数组或平衡搜索树中，我们可以快速地查找特定的元素。
2. 可扩展性：一些数据结构，如哈希表，可以随着数据的增长而有效地扩展。这使得我们可以在不牺牲太多性能的情况下处理更大的数据集。
3. 抽象性：数据结构通常隐藏了数据的实际表示方式，只提供一些基本的操作（如添加、删除和查找元素）。这使得程序员可以更专注于解决问题，而不必关心数据的具体组织方式。
4. 提升算法效率：合适的数据结构能够显著提高算法的运行效率。例如，二叉搜索树提供了高效的搜索、插入和删除操作，哈希表提供了近乎常数时间的搜索、插入和删除操作。
5. 缩小资源使用：合适的数据结构可以减少对计算机内存和存储资源的使用。

因此，选择和使用正确的数据结构是计算机编程中的关键任务之一。在设计和实现程序时，理解和掌握各种数据结构的工作原理和适用场景是非常重要的。

## 二、算法

算法是一组明确的规则或步骤，用于解决某种问题或执行某种任务的过程。在计算机科学中，算法通常用来处理数据、执行计算和自动推理。每个算法都有明确定义的输入和输出，以及清晰描述其操作的步骤。

### 1. 算法无处不在

当我们听到“算法”这个词时，很自然地会想到数学。然而实际上，许多算法并不涉及复杂数学，而是更多地依赖于基本逻辑，这些逻辑在我们的日常生活中处处可见。

在正式探讨算法之前，有一个有趣的事实值得分享：**实际上，你已经学会了许多算法，并习惯将他们应用到日常生活中了**。下面，我将举两个具体例子来证实这一点。

**例一：组装积木**。一套积木，除了包含许多零件之外，还附有详细的组装说明书。我们按照说明书一步步操作，就能组装出精美的积木模型。

从数据结构与算法的角度来看，积木的各种形状和连接方式代表数据结构，而组装说明书上的一系列步骤则是算法。

**例二：查阅字典**。在字典里，每个汉字都对应一个拼音，而字典是按照拼音的英文字母顺序排列的。假设我们需要查找一个拼音首字母为  `𝚛`的字，通常会这样操作：

1. 翻开字典约一半的页数，查看该页首字母是什么（假设为` 𝚖`）；
2. 由于在英文字母表中`𝚛` 位于 ` 𝚖`之后，所以排除字典前半部分，查找范围缩小到后半部分；
3. 不断重复步骤 1-2 ，直至找到拼音首字母为`𝚛`的页码为止。

<!-- tabs:start -->

#### **Step 1**

![查字典步骤](https://raw.githubusercontent.com/sanmaomashi/Salute_DataStructure/main/img/5.png)

#### **Step 2**

![look_up_dictionary_step_2](https://raw.githubusercontent.com/sanmaomashi/Salute_DataStructure/main/img/6.png)

#### **Step 3**

![look_up_dictionary_step_3](https://raw.githubusercontent.com/sanmaomashi/Salute_DataStructure/main/img/7.png)

#### **Step 4**

![look_up_dictionary_step_4](https://raw.githubusercontent.com/sanmaomashi/Salute_DataStructure/main/img/8.png)

#### **Step 5**

![look_up_dictionary_step_5](https://raw.githubusercontent.com/sanmaomashi/Salute_DataStructure/main/img/9.png)

<!-- tabs:end -->

查阅字典这个小学生必备技能，实际上就是著名的「二分查找」。从数据结构的角度，我们可以把字典视为一个已排序的「数组」；从算法的角度，我们可以将上述查字典的一系列操作看作是「二分查找」算法。

小到烹饪一道菜，大到星际航行，几乎所有问题的解决都离不开算法。计算机的出现使我们能够通过编程将数据结构存储在内存中，同时编写代码调用 CPU 和 GPU 执行算法。这样一来，我们就能把生活中的问题转移到计算机上，以更高效的方式解决各种复杂问题。

### 2. 算法的主要特性

1. 输入：一个算法应有零个或多个自定义的输入。
2. 输出：一个算法应有至少一个或多个自定义的输出，并且应与输入有所对应。
3. 明确性：算法的描述必须无歧义，以保证其实现的一致性。
4. 可行性：算法应当是可以实现的，不仅在理论上是可行的，实际上也应能通过有限的资源在有限时间内完成。
5. 有限性：如果算法在执行后能在有限的时间内停止，那么我们说该算法是有限的。

在计算机科学中，设计有效的算法是非常重要的。它决定了程序的运行速度和资源利用效率，直接影响到软件或系统的性能。算法的设计和分析是计算机科学中的一个重要领域，其中涵盖了许多不同类型的问题和解决方案，例如排序和查找算法、图算法、动态规划等。

## 三、算法与数据结构的区别

算法和数据结构是计算机科学中两个核心概念，虽然它们密切相关，但它们之间有着明显的区别。

**数据结构**是一种组织和存储数据的方式，它定义了数据的存储方式和数据之间的关系，以及对数据进行的各种操作。数据结构为数据提供了一种组织方式，以及在该组织下如何进行操作的一种方法。常见的数据结构包括数组、栈、队列、链表、树、图、哈希表等。

**算法**则是解决特定问题的一系列步骤或规则。它涉及到如何操作数据，以实现特定的功能或达到特定的结果。算法定义了应该执行哪些步骤，以及应该如何执行这些步骤以解决特定的问题。常见的算法包括排序算法（如冒泡排序、快速排序）、查找算法（如二分查找）、图算法（如深度优先搜索、广度优先搜索）等。

**程序 = 数据结构 + 算法**

![数据结构与算法的关系](https://raw.githubusercontent.com/sanmaomashi/Salute_DataStructure/main/img/4.png)

简单来说，数据结构是对数据的存储，而算法是对数据的处理。在编程中，我们通常会将算法应用到数据结构上，以解决实际问题。对数据结构和算法的深入理解和熟练掌握，对于编写高效的代码和构建高效的程序至关重要。

## 四、算法效率衡量

### 1. 引入

先来看一道题:

**如果 `a+b+c=1000`，且 `a²+b²=c²`（a,b,c 为自然数），如何求出所有a、b、c可能的组合?**

#### 第一次尝试

```python
import time

start_time = time.time()

# 注意是三重循环
for a in range(0, 1001):
    for b in range(0, 1001):
        for c in range(0, 1001):
            if a**2 + b**2 == c**2 and a+b+c == 1000:
                print("a, b, c: %d, %d, %d" % (a, b, c))

end_time = time.time()
print("elapsed: %f" % (end_time - start_time))
print("complete!")
```

运行结果：

```python
a, b, c: 0, 500, 500
a, b, c: 200, 375, 425
a, b, c: 375, 200, 425
a, b, c: 500, 0, 500
elapsed: 214.583347
complete!
```

**注意运行的时间:214.583347秒**

#### 第二次尝试

```python
import time

start_time = time.time()

# 注意是两重循环
for a in range(0, 1001):
    for b in range(0, 1001-a):
        c = 1000 - a - b
        if a**2 + b**2 == c**2:
            print("a, b, c: %d, %d, %d" % (a, b, c))

end_time = time.time()
print("elapsed: %f" % (end_time - start_time))
print("complete!")
```

运行结果：

```python
a, b, c: 0, 500, 500
a, b, c: 200, 375, 425
a, b, c: 375, 200, 425
a, b, c: 500, 0, 500
elapsed: 0.182897
complete!
```

**注意运行的时间:0.182897秒**

### 2. 执行时间反应算法效率

对于同一问题，我们给出了两种解决算法，在两种算法的实现中，我们对程序执行的时间进行了测算，发现两段程序执行的时间相差悬殊（214.583347秒相比于0.182897秒），由此我们可以得出结论：**实现算法程序的执行时间可以反应出算法的效率，即算法的优劣。**

但是，单靠时间值绝对可信吗？

假设我们将第二次尝试的算法程序运行在一台配置古老性能低下的计算机中，情况会如何？很可能运行的时间并不会比在我们的电脑中运行算法一的214.583347秒快多少。

**单纯依靠运行的时间来比较算法的优劣并不一定是客观准确的！**

程序的运行离不开计算机环境（包括硬件和操作系统），这些客观原因会影响程序运行的速度并反应在程序的执行时间上。那么如何才能客观的评判一个算法的优劣呢？

### 3. 时间复杂度与“大O记法”

我们假定计算机执行算法每一个基本操作的时间是固定的一个时间单位，那么有多少个基本操作就代表会花费多少时间单位。算然对于不同的机器环境而言，确切的单位时间是不同的，但是对于算法进行多少个基本操作（即花费多少时间单位）在规模数量级上却是相同的，由此可以忽略机器环境的影响而客观的反应算法的时间效率。

对于算法的时间效率，我们可以用“大O记法”来表示。

#### 大O记法

**对于单调的整数函数f，如果存在一个整数函数g和实常数c>0，使得对于充分大的n总有f(n)<=c\*g(n)，就说函数g是f的一个渐近函数（忽略常数），记为f(n)=O(g(n))。也就是说，在趋向无穷的极限意义下，函数f的增长速度受到函数g的约束，亦即函数f与函数g的特征相似。**

#### 时间复杂度

**假设存在函数g，使得算法A处理规模为n的问题示例所用时间为T(n)=O(g(n))，则称O(g(n))为算法A的渐近时间复杂度，简称时间复杂度，记为T(n)**

### 4. 如何理解“大O记法”

对于算法进行特别具体的细致分析虽然很好，但在实践中的实际价值有限。对于算法的时间性质和空间性质，最重要的是其数量级和趋势，这些是分析算法效率的主要部分。而计量算法基本操作数量的规模函数中那些常量因子可以忽略不计。例如，可以认为`3n²`和`100n²`属于同一个量级，如果两个算法处理同样规模实例的代价分别为这两个函数，就认为它们的效率“差不多”，都为`n²`级。

### 5. 最坏时间复杂度

分析算法时，存在几种可能的考虑：

- 算法完成工作最少需要多少基本操作，即**最优时间复杂度**
- 算法完成工作最多需要多少基本操作，即**最坏时间复杂度**
- 算法完成工作平均需要多少基本操作，即**平均时间复杂度**

对于最优时间复杂度，其价值不大，因为它没有提供什么有用信息，其反映的只是最乐观最理想的情况，没有参考价值。

对于最坏时间复杂度，提供了一种保证，表明算法在此种程度的基本操作中一定能完成工作。

对于平均时间复杂度，是对算法的一个全面评价，因此它完整全面的反映了这个算法的性质。但另一方面，这种衡量并没有保证，不是每个计算都能在这个基本操作内完成。而且，对于平均情况的计算，也会因为应用算法的实例分布可能并不均匀而难以计算。

**因此，我们主要关注算法的最坏情况，亦即最坏时间复杂度。**

### 6. 时间复杂度的几条基本计算规则

1. 基本操作，即只有常数项，认为其时间复杂度为O(1)
2. 顺序结构，时间复杂度按**加法**进行计算
3. 循环结构，时间复杂度按**乘法**进行计算
4. 分支结构，时间复杂度**取最大值**
5. 判断一个算法的效率时，往往只需要关注操作数量的最高次项，其它次要项和常数项可以忽略
6. 在没有特殊说明时，我们所分析的算法的时间复杂度都是指**最坏时间复杂度**

### 7. 算法分析

第一次尝试的算法核心部分

```python
for a in range(0, 1001):
    for b in range(0, 1001):
        for c in range(0, 1001):
            if a**2 + b**2 == c**2 and a+b+c == 1000:
                print("a, b, c: %d, %d, %d" % (a, b, c))
```

**时间复杂度：**

T(`n`) = O(`n*n*n`) = O(`n³`)

第二次尝试的算法核心部分

```python
for a in range(0, 1001):
    for b in range(0, 1001-a):
        c = 1000 - a - b
        if a**2 + b**2 == c**2:
            print("a, b, c: %d, %d, %d" % (a, b, c))
```

**时间复杂度：**

T(`n`) = O(`n*n*(1+1)`) = O(`n*n`) = O(`n²`)

**由此可见，我们尝试的第二种算法要比第一种算法的时间复杂度好多的。**

### 8. 常见时间复杂度

| 执行次数函数举例 |    阶    | 解释                                                         |
| ---------------- | :------: | :----------------------------------------------------------- |
| 12               |   O(1)   | 不论输入数据的规模如何，执行时间都是恒定的。例如，访问数组中的元素。 |
| 2n+3             |   O(n)   | 执行时间与输入数据规模成正比。例如，遍历数组中的每一个元素。 |
| 3n²+2n+1         |  O(n²)   | 执行时间与输入数据规模的平方成正比。例如，冒泡排序、插入排序等。 |
| 5log2n+20        | O(logn)  | 当输入数据规模增大时，执行时间会增长，但增长的速度会随着数据规模的增大而减慢。例如，二分搜索算法。 |
| 2n+3nlog2n+19    | O(nlogn) | 这是一种介于线性和二次之间的时间复杂度，常见的有快速排序、归并排序等。 |
| 6n³+2n²+3n+4     |  O(n3)   | 执行时间与输入数据规模的立方成正比。这种时间复杂度的算法通常在数据规模较小的情况下使用，例如Floyd算法或者简单的三层嵌套循环。 |
| 2ⁿ               |  O(2ⁿ)   | 执行时间与输入数据规模的指数。例如，解决旅行商问题的穷举搜索。 |

**注意，经常将log2n（以2为底的对数）简写成logn**

以下是它们之间的关系（从最快到最慢）：

O(`1`) < O(`log n`) < O(`n`) < O(`n log n`) < O(`n²`) < O(`n³`) < O(`2ⁿ `) < O(`n!`)

选择合适的算法和数据结构，可以使我们在解决问题时更有效地使用计算资源。注意，一个具有较低时间复杂度的算法不一定总是在实际使用中更快。例如，对于小规模的输入，一个 O(n^2) 的算法可能比一个 O(n log n) 的算法更快。这是因为时间复杂度通常不考虑常数因子和较小的项。

### 9. 空间复杂度分析

空间复杂度是对一个算法在运行过程中临时占用存储空间大小的度量。它也是衡量算法优劣的重要因素之一。

空间复杂度的计算通常包含以下几个部分：

1. 固定空间需求：这部分包括算法所需的固定空间，如常量、简单变量、函数参数等。不论程序运行时的不同情况，这部分空间的大小都是固定的。
2. 变量空间需求：这部分空间的大小与特定的情况有关，如大小为 n 的数组，递归栈等。这部分空间的大小在程序运行过程中是不断变化的。
3. 输出空间需求：如果问题规模 n 较大，输出所占用的空间也不能忽视。例如，深度或广度优先遍历图或树的情况，可能需要返回所有的遍历结果，这就涉及到输出空间的需求。

空间复杂度通常以大O符号表示，常见的空间复杂度有：O(1)、O(n)、O(n^2)，等等。例如，常数空间复杂度是 O(1)，线性空间复杂度是 O(n)，二维数组的空间复杂度是 O(n^2)，递归算法的空间复杂度等于递归深度，等等。

## 五、抽象数据类型(Abstract Data Type)

抽象数据类型（Abstract Data Type，ADT）是一种数据类型，其行为由一组操作定义，而不是其实现。这意味着我们只关心数据类型可以做什么，而不关心它是如何做的。

例如，我们可以定义一个 ADT 来表示“列表”这个概念。这个列表 ADT 可能包括操作如“添加元素”、“删除元素”、“检索元素”等。然而，ADT 不涉及这些操作的具体实现。列表可以通过数组实现，也可以通过链表实现，这是实现细节，不在 ADT 的定义中。

### 1. 定义抽象数据类型

定义抽象数据类型通常包括定义一组操作，这些操作描述了我们可以对数据类型做什么。例如，如果我们定义一个 ADT 来表示堆栈（stack），我们可能会包括以下操作：

- `push(item)`: 在堆栈顶部添加一个元素。
- `pop()`: 删除并返回堆栈顶部的元素。
- `peek()`: 返回堆栈顶部的元素，但不删除它。
- `isEmpty()`: 如果堆栈为空，则返回 True，否则返回 False。

注意这里并没有提到如何实现这些操作。实际上，我们可以用数组或链表来实现堆栈，这取决于具体的实现。

### 2. 实现抽象数据类型

虽然 ADT 的定义不涉及实现细节，但在编程时，我们需要选择一种方法来实现 ADT 的操作。以下是一个用 Python 的 list 实现上述堆栈 ADT 的例子：

```python
class Stack:
    def __init__(self):
        self.items = []
        
    def push(self, item):
        self.items.append(item)
        
    def pop(self):
        return self.items.pop()
        
    def peek(self):
        return self.items[-1]
        
    def isEmpty(self):
        return not bool(self.items)
```

在这个例子中，我们用 Python 的 list 实现了堆栈的操作。但请注意，用户不需要知道这些细节。他们只需要知道堆栈有哪些操作，以及如何使用这些操作。

### 3. 使用抽象数据类型

使用 ADT 时，我们不关心其实现细节，只关心其提供的操作。这使我们可以更专注于解决问题，而不必深入理解数据的组织方式。例如，如果我们有一个 Stack 对象，我们可以像下面这样使用它：

```python
s = Stack()
s.push('hello')
s.push('world')
print(s.pop())  # 输出：world
print(s.peek())  # 输出：hello
```

总的来说，抽象数据类型提供了一种封装数据的方法，使我们可以将注意力从数据的实现细节转移到如何使用数据上。它是面向对象编程的重要概念，有助于提高代码的可读性和可维护性。