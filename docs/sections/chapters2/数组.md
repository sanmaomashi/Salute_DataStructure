# 数组

## 一、数组概述

「数组 Array」是一种线性数据结构，其将相同类型元素存储在连续的内存空间中。我们将元素在数组中的位置称为元素的「索引 Index」

![数组定义与存储方式](https://raw.githubusercontent.com/sanmaomashi/Salute_DataStructure/main/img/17.png)

**数组初始化**。通常有无初始值和给定初始值两种方式，我们可根据需求选择合适的方法。在未给定初始值的情况下，数组的所有元素通常会被初始化为默认值 0 。

?> 为什么数组元素的索引要从 0 开始编号呢？<br>观察上图，我们发现数组首个元素的索引为 0 ，这似乎有些反直觉，因为从 1 开始计数会更自然。<br>然而，从地址计算公式的角度看，**索引本质上表示的是内存地址的偏移量**。首个元素的地址偏移量是 0 ，因此索引为 0 也是合理的。

如果数组的下标有多个维度，即为多维数组。比如：二维数组可以视为『数组元素为一维数组』的一维数组；三维数组可以视为『数组元素为二维数组』的一维数组；依次类推。

下图是由 M 个行向量，N 个列向量组成的二维数组。

![img](https://raw.githubusercontent.com/sanmaomashi/Salute_DataStructure/main/img/14.png)

## 二、数组实现

```python
arr: List[int] = [0] * 5  # [ 0, 0, 0, 0, 0 ]
nums: List[int] = [1, 3, 2, 5, 4]  
```

## 三、数组优缺点

### 1. 数组优点

**在数组中访问元素非常高效**。由于数组元素被存储在连续的内存空间中，因此计算数组元素的内存地址非常容易。给定数组首个元素的地址和某个元素的索引，我们可以使用以下公式计算得到该元素的内存地址，从而直接访问此元素。

![数组元素的内存地址计算](https://raw.githubusercontent.com/sanmaomashi/Salute_DataStructure/main/img/18.png)

> 元素内存地址 = 数组内存地址 + 元素长度 * 元素索引 

$$
elementAddr = firtstElementAddr + elementLength * elementIndex
$$

### 2. 数组缺点

**数组在初始化后长度不可变**。由于系统无法保证数组之后的内存空间是可用的，因此数组长度无法扩展。而若希望扩容数组，则需新建一个数组，然后把原数组元素依次拷贝到新数组，在数组很大的情况下，这是非常耗时的。

**数组中插入或删除元素效率低下**。如果我们想要在数组中间插入一个元素，由于数组元素在内存中是“紧挨着的”，它们之间没有空间再放任何数据。因此，我们不得不将此索引之后的所有元素都向后移动一位，然后再把元素赋值给该索引。

![数组插入元素](https://raw.githubusercontent.com/sanmaomashi/Salute_DataStructure/main/img/12.png)

删除元素也类似，如果我们想要删除索引`i`处的元素，则需要把索引`i`之后的元素都向前移动一位。值得注意的是，删除元素后，原先末尾的元素变得“无意义”了，我们无需特意去修改它。

![数组删除元素](https://raw.githubusercontent.com/sanmaomashi/Salute_DataStructure/main/img/13.png)

总结来看，数组的插入与删除操作有以下缺点：

- **时间复杂度高**：数组的插入和删除的平均时间复杂度均为 `O(n) `，其中`n`为数组长度。
- **丢失元素**：由于数组的长度不可变，因此在插入元素后，超出数组长度范围的元素会丢失。
- **内存浪费**：我们可以初始化一个比较长的数组，只用前面一部分，这样在插入数据时，丢失的末尾元素都是我们不关心的，但这样做同时也会造成内存空间的浪费。

## 四、数组常用操作

### 1. 创建数组

在大多数编程语言中，创建数组的语法大致相同。以下是在Python中创建数组的示例：

```python
arr = [1, 2, 3, 4, 5]
```

### 2. 插入元素

可以在数组的任何位置插入元素。但是要注意，数组的大小是固定的，所以在插入元素时，可能需要创建一个新的数组来容纳更多的元素。以下是在Python中在数组的末尾插入元素的示例：

```python
arr.append(6)  # 将元素 6 插入数组的末尾
```

### 3. 删除元素

可以删除数组中的元素。在删除元素后，可能需要移动其他元素来填充空白空间。以下是在Python中删除数组中的元素的示例：

```python
arr.remove(2)  # 将元素 2 从数组中删除
```

### 4. 访问元素

可以通过索引访问数组中的元素。索引通常从 0 开始。以下是在Python中访问数组元素的示例：

```python
first_element = arr[0]  # 访问数组的第一个元素 
```

### 5. 数组遍历

```python
def traverse(nums: list[int]) -> None:
    """遍历数组"""
    count = 0
    # 通过索引遍历数组
    for i in range(len(nums)):
        count += 1
    # 直接遍历数组
    for num in nums:
        count += 1
    # 同时遍历数据索引和元素
    for i, num in enumerate(nums):
        count += 1
```

### 6. 数组查找

通过遍历数组，查找数组内的指定元素，并输出对应索引。

```python
def find(nums: list[int], target: int) -> int:
    """在数组中查找指定元素"""
    for i in range(len(nums)):
        if nums[i] == target:
            return i
    return -1
```

## 五、应用 

**随机访问**。如果我们想要随机抽取一些样本，那么可以用数组存储，并生成一个随机序列，根据索引实现样本的随机抽取。

**二分查找**。例如前文查字典的例子，我们可以将字典中的所有字按照拼音顺序存储在数组中，然后使用与日常查纸质字典相同的“翻开中间，排除一半”的方式，来实现一个查电子字典的算法。

**深度学习**。神经网络中大量使用了向量、矩阵、张量之间的线性代数运算，这些数据都是以数组的形式构建的。数组是神经网络编程中最常使用的数据结构。

## 六、数组时间空间复杂度

数组是计算机科学中最基本的数据结构之一，也是很多更复杂的数据结构的基础。对于数组的不同操作，它们的时间和空间复杂度有所不同。下面是一些基本的数组操作及其对应的时间和空间复杂度。

### 1. 访问

时间复杂度：O(1)

空间复杂度：O(1)

解析：在数组中，我们可以直接通过索引访问元素。因此，无论数组多大，访问一个元素的时间和空间复杂度都是常数。

### 2. 搜索

时间复杂度：O(n)

空间复杂度：O(1)

解析：在未排序的数组中搜索一个元素可能需要遍历整个数组，因此时间复杂度为 O(n)，其中 n 是数组的长度。搜索不需要额外的空间，因此空间复杂度是常数。

### 3. 插入

时间复杂度：O(n)

空间复杂度：O(n)

解析：在数组中插入一个元素可能需要移动后续的元素以保持连续性，因此时间复杂度为 O(n)。如果数组没有足够的空间，可能需要创建一个新的数组，这就涉及到 O(n) 的空间复杂度。

### 4. 删除

时间复杂度：O(n)

空间复杂度：O(n)

解析：在数组中删除一个元素也可能需要移动后续的元素。因此，删除操作的时间复杂度为 O(n)。同样，如果在删除后，数组有很多空闲空间，我们可能希望创建一个新的数组，因此空间复杂度也可能为 O(n)。

这些复杂度分析是基于最坏情况的。在一些特殊情况下，如插入元素在数组的末尾，或者删除元素在数组的末尾，这些操作的时间复杂度可能会更低。